'use strict';

/* Builtin Modules */
var path         = require('path');
var URL          = require('url').URL;
var childProcess = require('child_process');

/* 3rd-party Modules */
var async         = require('async');
var yaml          = require('js-yaml');
var fs            = require('fs-extra');
var markdownTable = require('markdown-table');
var stringWidth   = require('string-width');
var simpleGit     = require('simple-git');
var sortedJSON    = require('sorted-json');

/* Project Modules */
var E       = require('../utils/serverError');
var CONFIG  = require('../utils/yamlResources').get('CONFIG');
var toolkit = require('../utils/toolkit');
var common  = require('../utils/common');

var scriptMod       = require('../models/scriptMod');
var scriptSetMod    = require('../models/scriptSetMod');
var scriptMarketMod = require('../models/scriptMarketMod');
const { file } = require('jszip');

/* Configure */
var AUTO_GENERATION_INFO_TEXT = 'This file is auto generated by DataFlux Func';

var OSSUTIL_CMD = path.join(__dirname, `../../tools/${process.arch === 'x64' ? 'ossutil64' : 'ossutilarm64'}`);

var SCRIPT_MARKET_RW_MAP = {
  git        : 'rw',
  aliyunOSS  : 'rw',
  httpService: 'ro',
}

function _prepareConfig(data) {
  if (toolkit.isNothing(data.configJSON)) return data;

  ['url', 'endpoint', 'folder'].forEach(function(f) {
    if (data.configJSON[f]) {
      data.configJSON[f] = data.configJSON[f].replace(/\/*$/g, '').replace(/^\/*/g, '');
    }
  });

  return data;
};

function _checkConfig(locals, data, callback) {
  var type   = data.type;
  var config = data.configJSON;

  var requiredFields = [];
  var optionalFields = [];

  switch(type) {
    case 'git':
      requiredFields = ['url'];
      optionalFields = ['branch', 'user', 'password'];
      break;

    case 'aliyunOSS':
      requiredFields = ['endpoint', 'bucket', 'folder'];
      optionalFields = ['accessKeyId', 'accessKeySecret'];
      break;

    case 'httpService':
      requiredFields = ['url'];
      optionalFields = [];
      break;
  }

  // 检查字段
  for (var i = 0; i < requiredFields.length; i++) {
    var f = requiredFields[i];

    if ('undefined' === typeof config[f]) {
      return callback(new E('EClientBadRequest.InvalidScriptMarketAuthJSON', 'Invalid config JSON', {
        requiredFields: requiredFields,
        optionalFields: optionalFields,
        missingField  : f,
      }));
    }
  }

  // TODO 尝试连接
  return callback();
};

function _getGitRepoAuthURL(scriptMarket) {
  var config = scriptMarket.configJSON || {};
  var urlObj = new URL(config.url);
  urlObj.username = config.user     || 'anonymity';
  urlObj.password = config.password || 'anonymity';

  return urlObj.toString();
};

function _getToken(scriptMarket) {
  if (!scriptMarket.id) {
    throw new Error('No Script Market ID');
  }

  return toolkit.getStringSign(scriptMarket.id);
};

function _getRemoteTokenInfo(scriptMarket) {
  var localPath = _getLocalAbsPath(scriptMarket);

  var tokenFilePath = path.join(localPath, CONFIG.SCRIPT_MARKET_TOKEN_FILE);
  var remoteToken   = toolkit.safeReadFileSync(tokenFilePath).trim();

  var info = {
    path : tokenFilePath,
    value: remoteToken,
  }
  return info;
};

function _getGitErrDetail(err) {
  var errorMessage = err.toString().trim().split('\n').pop();
  var errDetail = {
    message: errorMessage,
  };
  return errDetail;
};

function _addAutoGeneratedInfo(text, style) {
  var infoLine = '';
  switch(style) {
    case 'html':
    case 'markdown':
      infoLine = `<!-- ${AUTO_GENERATION_INFO_TEXT} -->`;
      break;

    case 'yaml':
    case 'python':
      infoLine = `# ${AUTO_GENERATION_INFO_TEXT}`;
      break;

    default:
      infoLine = AUTO_GENERATION_INFO_TEXT;
      break;
  }
  return [ infoLine, text ].join('\n\n');
};

function _addChangelogInfo(changelogInfo, scriptSet) {
  if (toolkit.isNothing(changelogInfo)) {
    changelogInfo = {
      title     : '变更日志 / Changelog',
      changelogs: [],
    }
  }

  changelogInfo.changelogs.push({
    time: scriptSet._exportTime,
    by  : scriptSet._exportUser,
    note: scriptSet._note,
  });

  return changelogInfo;
};

function _isAutoGeneratedFileOrNothing(filePath) {
  if (!fs.existsSync(filePath)) return true;

  var text = toolkit.safeReadFileSync(filePath).trim();
  if (toolkit.isNothing(text) || text.split('\n')[0].indexOf(AUTO_GENERATION_INFO_TEXT) >= 0) {
    return true;
  }

  return false;
};

function _getMarkdownTable(body) {
  return markdownTable(body, { stringLength: stringWidth });
};

function _getDefaultScriptMarketReadmeContent(scriptMarket, pushContent) {
  var addrTitle = null;
  var addrValue = null;
  switch(scriptMarket.type) {
    case 'git':
    case 'httpService':
      addrTitle = '地址 / URL';
      addrValue = scriptMarket.configJSON.url;
      break;

    case 'aliyunOSS':
      addrTitle = '地址 / Endpoint';

      var endpointObj = new URL(scriptMarket.configJSON.endpoint);
      addrValue = `${scriptMarket.configJSON.bucket}.${endpointObj.hostname}/${scriptMarket.configJSON.folder}`;
      break;
  }

  // 脚本市场信息
  var content = [
    `# 脚本市场 / Script Market${scriptMarket.name ? ' - ' + scriptMarket.name : ''}`,
    _getMarkdownTable([
      [ '名称 / Name', addrTitle ],
      [
        `${scriptMarket.name || '-'}`,
        `\`${addrValue}\``,
      ],
    ]),

    `<br>`,
    `## 1. 描述 / Description`,
    `${toolkit.toMarkdownTextBlock(scriptMarket.description) || '*没有具体描述*<br>*No description*'}`,
  ];

  // 脚本集信息
  if (toolkit.notNothing(pushContent.deleteScriptSets)) {
    content.push(`<br>`,
                  `## 2. 最近删除 / Recent Deleted`,
                  toolkit.toMarkdownTextBlock(pushContent.note));
    var _table = [
      [ '#', 'ID', '标题 / Title', '目录 / Directory', '删除时间 / Delete Time' ],
    ];
    var deleteTimeCN = toolkit.getDateTimeStringCN();
    pushContent.deleteScriptSets.forEach(function(scriptSet, index) {
      _table.push([
        `${index + 1}`,
        `\`${scriptSet.id}\``,
        `${scriptSet.title || '-'}`,
        `${CONFIG.SCRIPT_MARKET_SCRIPT_SET_DIR}/${scriptSet.id}`,
        deleteTimeCN,
      ])
    });

    content.push(_getMarkdownTable(_table));
  }

  if (toolkit.notNothing(pushContent.scriptSets)) {
    content.push(`<br>`,
                  `## 2. 最近发布 / Recent Published`,
                  toolkit.toMarkdownTextBlock(pushContent.note));

    var _table = [
      [ '#', 'ID', '标题 / Title', '目录 / Directory', '发布者 / Publisher', '发布时间 / Publish Time' ],
    ];
    pushContent.scriptSets.forEach(function(scriptSet, index) {
      _table.push([
        `${index + 1}`,
        `\`${scriptSet.id}\``,
        `${scriptSet.title || '-'}`,
        `[${CONFIG.SCRIPT_MARKET_SCRIPT_SET_DIR}/${scriptSet.id}](${CONFIG.SCRIPT_MARKET_SCRIPT_SET_DIR}/${scriptSet.id})`,
        `${pushContent.exportUser}`,
        `${toolkit.getDateTimeStringCN(pushContent.exportTime)}`,
      ])
    });

    content.push(_getMarkdownTable(_table));
  }

  // 脚本集总表
  var scriptSets = _getMetaData(scriptMarket).scriptSets || [];
  if (scriptSets.length > 0) {
    content.push(`<br>`,
                  `## 3. 总览 / Overview`,
                  `此脚本市场包含以下脚本集：<br>This Script Market contains the following Scripts Sets:  `);

    var _table = [
      [ '#', 'ID', '标题 / Title', '目录 / Directory', '发布者 / Publisher', '发布时间 / Publish Time' ],
    ];
    scriptSets.forEach(function(scriptSet, index) {
      _table.push([
        `${index + 1}`,
        `\`${scriptSet.id}\``,
        `${scriptSet.title || '-'}`,
        `[${CONFIG.SCRIPT_MARKET_SCRIPT_SET_DIR}/${scriptSet.id}](${CONFIG.SCRIPT_MARKET_SCRIPT_SET_DIR}/${scriptSet.id})`,
        `${scriptSet._exportUser}`,
        `${toolkit.getDateTimeStringCN(scriptSet._exportTime)}`,
      ]);
    });
    content.push(_getMarkdownTable(_table));

  } else {
    content.push(`<br>`,
                  `## 3. 总览 / Overview`,
                  `此脚本市场暂不包含任何脚本集：<br>This Script Market does not contains any Scripts Set.  `);
  }

  return _addAutoGeneratedInfo(content.join('\n\n'), 'markdown');
};

function _getDefaultScriptSetReadmeContent(scriptSet) {
  // 脚本集信息
  var content = [
    `# ${scriptSet.title || scriptSet.id}`,
    _getMarkdownTable([
      [ 'ID', '标题 / Title', '发布者 / Publisher', '发布时间 / Publish Time' ],
      [
        `\`${scriptSet.id}\``,
        `${scriptSet.title || '-'}`,
        `${scriptSet._exportUser}`,
        `${toolkit.getDateTimeStringCN(scriptSet._exportTime)}`,
      ],
    ]),

    `<br>`,
    `## 1. 描述 / Description`,
    `${toolkit.toMarkdownTextBlock(scriptSet.description) || '*没有具体描述*<br>*No description*'}`,

    `<br>`,
    `## 2. 依赖包 / Dependency`,
    toolkit.isNothing(scriptSet.requirements)
      ? `*不需要任何依赖包*<br>*No dependency required*`
      : `~~~text\n${scriptSet.requirements.trim()}\n~~~`,
  ];

  if (toolkit.notNothing(scriptSet.scripts)) {
    // 脚本信息
    content.push(`<br>`,
                  `## 3. 脚本 / Scripts`,
                  `此脚本集包含以下脚本：<br>This Script Set contains the following Scripts:  `);

    var _table = [
      [ '#', 'ID', '标题 / Title', '行数 / Lines', '更新时间 / Update Time' ],
    ];
    var codeLines = 0;
    scriptSet.scripts.forEach(function(s, index) {
      var lines = 0;
      if ('string' === typeof s.code) {
        lines = s.code.split('\n').length;
        codeLines += lines;
      }

      var filename = common.getScriptFilename(s);
      _table.push([
        `${index + 1}`,
        `[\`${s.id}\`](${filename})`,
        `${s.title || '-'}`,
        lines,
        `${toolkit.getDateTimeStringCN(s.updateTime)}`,
      ]);
    });
    content.push(_getMarkdownTable(_table));

    // 统计
    content.push(`<br>`,
                  `## 4. 统计 / Statistics`,
                  `此脚本集统计信息如下：<br>The statistics of this Script Set are as follows:   `);

    content.push(_getMarkdownTable([
      [ '项目 / Item', '结果 / Result' ],
      [ '脚本数量 / Script Count', scriptSet.scripts.length ],
      [ '脚本总行数 / Total Lines', codeLines ],
    ]));
  }

  return _addAutoGeneratedInfo(content.join('\n\n'), 'markdown');
};

function _getDefaultScriptSetChangelogContent(changelogInfo) {
  var content = [
    `# ${changelogInfo.title}`,
  ]
  for (var i = changelogInfo.changelogs.length - 1; i >= 0; i--) {
    var changelog = changelogInfo.changelogs[i];

    content.push(`<br>`,
                  `## ${toolkit.getDateStringCN(changelog.time || changelog.date)}`,
                  '<br>',
                  `> BY ${changelog.by}`);
    content.push(toolkit.toMarkdownTextBlock(changelog.note));
  };

  return _addAutoGeneratedInfo(content.join('\n\n'), 'markdown');
};

// 脚本市场 - 初始化
var SCRIPT_MARKET_INIT_FUNC_MAP = {
  git: function(locals, scriptMarket, callback) {
    var gitURL       = _getGitRepoAuthURL(scriptMarket);
    var localPath    = _getLocalAbsPath(scriptMarket);
    var localPathTmp = `${localPath}.tmp`;

    // 清理目录
    fs.emptyDirSync(localPathTmp);

    // 操作 git
    var git = toolkit.createGitHandler(localPathTmp);
    async.series([
      // git clone
      function(asyncCallback) {
        var opt = {
          '--depth': 1,
        };
        if (scriptMarket.configJSON && scriptMarket.configJSON.branch) {
          opt['--branch'] = scriptMarket.configJSON.branch;
        }

        git.clone(gitURL, localPathTmp, opt, function(err) {
          if (err) {
            var errDetail = _getGitErrDetail(err);
            if (errDetail.message.indexOf('--depth=1') >= 0) {
              // 空库，重新尝试
              delete opt['--depth'];
              return git.clone(gitURL, localPathTmp, opt, asyncCallback);

            } else {
              // 非空库，直接中断
              return asyncCallback(err);
            }
          }

          return asyncCallback();
        });
      },
    ], function(err) {
      // 克隆失败
      if (err) {
        fs.removeSync(localPathTmp);
        return callback(new E('EClient', 'Load Script Market failed', { message: err.toString() }));
      }

      fs.moveSync(localPathTmp, localPath, { overwrite: true });
      fs.removeSync(localPathTmp);
      return callback();
    });
  },
  aliyunOSS: function(locals, scriptMarket, callback) {
    var localPath    = _getLocalAbsPath(scriptMarket);
    var localPathTmp = `${localPath}.tmp`;

    // 清理目录
    fs.emptyDirSync(localPathTmp);

    async.series([
      // 下载初始化文件
      function(asyncCallback) {
        var files = [
          CONFIG.SCRIPT_MARKET_META_FILE,
          CONFIG.SCRIPT_MARKET_TOKEN_FILE,
        ];
        async.eachSeries(files, function(file, eachCallback) {
          SCRIPT_MARKET_DOWNLOAD_FUNC_MAP[scriptMarket.type](scriptMarket, localPathTmp, file, function(err) {
            // 初始化时下载文件失败不报错
            return eachCallback();
          });
        }, asyncCallback);
      },
    ], function(err) {
      // 初始化失败
      if (err) {
        fs.removeSync(localPathTmp);
        return callback(new E('EClient', 'Init Script Market failed', { message: err.toString() }));
      }

      fs.moveSync(localPathTmp, localPath, { overwrite: true });
      fs.removeSync(localPathTmp);
      return callback();
    });
  },
};
SCRIPT_MARKET_INIT_FUNC_MAP.httpService = SCRIPT_MARKET_INIT_FUNC_MAP.aliyunOSS;

// 脚本市场 - 重置
var SCRIPT_MARKET_RESET_FUNC_MAP = {
  git: function(locals, scriptMarket, callback) {
    var localPath = _getLocalAbsPath(scriptMarket);
    var git = toolkit.createGitHandler(localPath);

    var prevCommitId = null;

    var lockKey     = toolkit.getCacheKey('lock', 'scriptMarketOperation');
    var lockValue   = toolkit.genRandString();
    var lockAge     = CONFIG._SCRIPT_MARKET_OPERATION_LOCK_AGE;
    var lockWaitAge = CONFIG._SCRIPT_MARKET_OPERATION_LOCK_WAIT_AGE;
    async.series([
      // 上锁
      function(asyncCallback) {
        locals.cacheDB.lockWait(lockKey, lockValue, lockAge, lockWaitAge, asyncCallback);
      },
      // 获取 Commit ID
      function(asyncCallback) {
        git.revparse(['HEAD'], function(err, commitId) {
          prevCommitId = commitId || null;

          // 忽略空库报错
          return asyncCallback();
        })
      },
      // git reset
      function(asyncCallback) {
        git.reset(simpleGit.ResetMode.HARD, asyncCallback);
      },
      // git clean
      function(asyncCallback) {
        git.clean(simpleGit.CleanOptions.FORCE, asyncCallback);
      },
      // git pull
      function(asyncCallback) {
        if (!prevCommitId) return asyncCallback();

        git.pull(asyncCallback);
      },
    ], function(err) {
      // 解锁
      locals.cacheDB.unlock(lockKey, lockValue, function() {
        if (err) {
          if (err instanceof simpleGit.GitPluginError && err.plugin === 'timeout') {
            return callback(new E('EClient', 'Accessing git repo timeout'));
          } else {
            return callback(err);
          }
        }

        // 读取 META
        var metaFilePath = path.join(localPath, CONFIG.SCRIPT_MARKET_META_FILE);
        var metaData = toolkit.safeReadFileSync(metaFilePath, 'yaml') || {};
        return callback(null, metaData);
      });
    });
  },
  aliyunOSS: function(locals, scriptMarket, callback) {
    var localPath = _getLocalAbsPath(scriptMarket);

    var lockKey     = toolkit.getCacheKey('lock', 'scriptMarketOperation');
    var lockValue   = toolkit.genRandString();
    var lockAge     = CONFIG._SCRIPT_MARKET_OPERATION_LOCK_AGE;
    var lockWaitAge = CONFIG._SCRIPT_MARKET_OPERATION_LOCK_WAIT_AGE;
    async.series([
      // 上锁
      function(asyncCallback) {
        locals.cacheDB.lockWait(lockKey, lockValue, lockAge, lockWaitAge, asyncCallback);
      },
      // 重新下载 META、TOKEN
      function(asyncCallback) {
        var files = [
          CONFIG.SCRIPT_MARKET_META_FILE,
          CONFIG.SCRIPT_MARKET_TOKEN_FILE,
        ];
        async.eachSeries(files, function(file, eachCallback) {
          SCRIPT_MARKET_DOWNLOAD_FUNC_MAP[scriptMarket.type](scriptMarket, localPath, file, function(err) {
            // 初始化时下载文件失败不报错
            return eachCallback();
          });
        }, asyncCallback);
      },
    ], function(err) {
      // 解锁
      locals.cacheDB.unlock(lockKey, lockValue, function() {
        if (err) return callback(err);

        // 读取 META
        var metaFilePath = path.join(localPath, CONFIG.SCRIPT_MARKET_META_FILE);
        var metaData = toolkit.safeReadFileSync(metaFilePath, 'yaml') || {};
        return callback(null, metaData);
      });
    });
  },
};
SCRIPT_MARKET_RESET_FUNC_MAP.httpService = SCRIPT_MARKET_RESET_FUNC_MAP.aliyunOSS;

// 脚本市场 - 下载
var SCRIPT_MARKET_DOWNLOAD_FUNC_MAP = {
  git: function(scriptMarket, localPath, files, callback) {
    // Git 库通过重置实现下载
    return callback();
  },
  aliyunOSS: function(scriptMarket, localSavePath, file, callback) {
    var ossFilePath   = `oss://${scriptMarket.configJSON.bucket}/${scriptMarket.configJSON.folder}/${file}`;
    var localFilePath = path.join(localSavePath, file);
    var ossEndpoint   = scriptMarket.configJSON.endpoint;

    // 确保文件夹
    fs.ensureDirSync(path.dirname(localFilePath));

    // 删除原文件
    fs.removeSync(localFilePath);

    // 下载文件
    var cmdArgs = [
      'cp', ossFilePath, localFilePath, '-f',
      '-e', ossEndpoint,
      '-i', scriptMarket.configJSON.accessKeyId,
      '-k', scriptMarket.configJSON.accessKeySecret,
    ]
    if (toolkit.endsWith(file, '/')) cmdArgs.push('-r');

    var t = Date.now()
    childProcess.execFile(OSSUTIL_CMD, cmdArgs, function(err, stdout, stderr) {
      if (err) return callback(err);

      if (!fs.existsSync(localFilePath)) {
        return callback(new Error('Fetch file from Aliyun OSS failed.'))
      }
      return callback();
    })
  },
  httpService: function(scriptMarket, localSavePath, file, callback) {
    var fileURL       = `${scriptMarket.configJSON.url}/${file}`;
    var localFilePath = path.join(localSavePath, file);

    // 确保文件夹
    fs.ensureDirSync(path.dirname(localFilePath));

    // 删除原文件
    fs.removeSync(localFilePath);

    // 下载文件
    var cmdArgs = [ fileURL, '-q', '-O', localFilePath ];

    var t = Date.now()
    childProcess.execFile('wget', cmdArgs, function(err, stdout, stderr) {
      if (err) return callback(err);

      if (!fs.existsSync(localFilePath)) {
        return callback(new Error('Fetch file from HTTP Service failed.'))
      }
      return callback();
    });
  },
}

// 脚本市场 - 上传
var SCRIPT_MARKET_UPLOAD_REPO_FUNC_MAP = {
  git: function(locals, scriptMarket, pushContent, callback) {
    var localPath = _getLocalAbsPath(scriptMarket);
    var git = toolkit.createGitHandler(localPath);

    var prevCommitId = null;

    var lockKey     = toolkit.getCacheKey('lock', 'scriptMarketOperation');
    var lockValue   = toolkit.genRandString();
    var lockAge     = CONFIG._SCRIPT_MARKET_OPERATION_LOCK_AGE;
    var lockWaitAge = CONFIG._SCRIPT_MARKET_OPERATION_LOCK_WAIT_AGE;
    async.series([
      // 上锁
      function(asyncCallback) {
        locals.cacheDB.lockWait(lockKey, lockValue, lockAge, lockWaitAge, asyncCallback);
      },
      // 获取 Commit ID
      function(asyncCallback) {
        git.revparse(['HEAD'], function(err, commitId) {
          prevCommitId = commitId || null;

          // 忽略空库报错
          return asyncCallback();
        })
      },
      // git add
      function(asyncCallback) {
        git.add('.', asyncCallback);
      },
      // git commit
      function(asyncCallback) {
        git.addConfig('user.name', locals.user.name)
        git.addConfig('user.email', locals.user.email)
        git.commit(pushContent.note, asyncCallback);
      },
      // git push / reset
      function(asyncCallback) {
        git.push(function(err) {
          if (err) {
            return git.raw(['reset', '--hard', prevCommitId], function() {
              // 保证错误依旧抛出
              return asyncCallback(err);
            })
          }

          return asyncCallback();
        });
      },
    ], function(err) {
      // 解锁
      locals.cacheDB.unlock(lockKey, lockValue, function() {
        if (err) {
          if (err instanceof simpleGit.GitPluginError && err.plugin === 'timeout') {
            return callback(new E('EClient', 'Accessing git repo timeout'));
          } else {
            return callback(err);
          }
        }
        return callback();
      });
    });
  },
  aliyunOSS: function(locals, scriptMarket, pushContent, callback) {
    if (toolkit.isNothing(pushContent)) return callback();

    var localPath   = _getLocalAbsPath(scriptMarket);
    var ossPath     = `oss://${scriptMarket.configJSON.bucket}/${scriptMarket.configJSON.folder}/`;
    var ossEndpoint = scriptMarket.configJSON.endpoint;

    var lockKey     = toolkit.getCacheKey('lock', 'scriptMarketOperation');
    var lockValue   = toolkit.genRandString();
    var lockAge     = CONFIG._SCRIPT_MARKET_OPERATION_LOCK_AGE;
    var lockWaitAge = CONFIG._SCRIPT_MARKET_OPERATION_LOCK_WAIT_AGE;
    async.series([
      // 上锁
      function(asyncCallback) {
        locals.cacheDB.lockWait(lockKey, lockValue, lockAge, lockWaitAge, asyncCallback);
      },
      // 上传固定文件
      function(asyncCallback) {
        var files = [
          CONFIG.SCRIPT_MARKET_META_FILE,
          CONFIG.SCRIPT_MARKET_TOKEN_FILE,
          CONFIG.SCRIPT_EXPORT_README_FILE,
        ]
        async.eachSeries(files, function(file, eachCallback) {
          var localFilePath = path.join(localPath, file);
          var ossFilePath   = ossPath + file;
          var cmdArgs = [
            'cp', localFilePath, ossFilePath, '-f',
            '-e', ossEndpoint,
            '-i', scriptMarket.configJSON.accessKeyId,
            '-k', scriptMarket.configJSON.accessKeySecret
          ];
          if (toolkit.endsWith(file, '/')) cmdArgs.push('-r');

          childProcess.execFile(OSSUTIL_CMD, cmdArgs, function(err, stdout, stderr) {
            if (err) return eachCallback(stderr.toString() || stdout.toString());
            return eachCallback();
          });
        }, asyncCallback);
      },
      // 上传脚本集文件
      function(asyncCallback) {
        if (toolkit.isNothing(pushContent.scriptSets)) return asyncCallback();

        async.eachSeries(pushContent.scriptSets, function(scriptSet, eachCallback) {
          var localFolderPath = path.join(localPath, CONFIG.SCRIPT_MARKET_SCRIPT_SET_DIR, scriptSet.id) + '/';
          var ossFolderPath   = ossPath + `${CONFIG.SCRIPT_MARKET_SCRIPT_SET_DIR}/${scriptSet.id}/`;
          var cmdArgs = [
            'cp', localFolderPath, ossFolderPath, '-r', '-f',
            '-e', ossEndpoint,
            '-i', scriptMarket.configJSON.accessKeyId,
            '-k', scriptMarket.configJSON.accessKeySecret
          ];

          childProcess.execFile(OSSUTIL_CMD, cmdArgs, function(err, stdout, stderr) {
            if (err) return eachCallback(stderr.toString() || stdout.toString());
            return eachCallback();
          });
        }, asyncCallback);
      },
    ], function(err) {
      // 解锁
      locals.cacheDB.unlock(lockKey, lockValue, function() {
        if (err) return callback(err);
        return callback();
      });
    });
  },
  httpService: function(locals, scriptMarket, pushContent, callback) {
    return callback(new E('EClient', 'Publishing is not supported on HTTP Service'));
  },
};

// 脚本市场 - 获取本地目录
function _getLocalAbsPath(scriptMarket) {
  switch(scriptMarket.type) {
    case 'git':
      var urlObj = new URL(scriptMarket.configJSON.url);
      var localAbsPath = path.join(
          CONFIG.RESOURCE_ROOT_PATH,
          CONFIG.SCRIPT_MARKET_GIT_REPO_DIR,
          `${urlObj.hostname}${urlObj.pathname}`);

      return localAbsPath;

    case 'aliyunOSS':
      var endpointObj = new URL(scriptMarket.configJSON.endpoint);
      var localAbsPath = path.join(
          CONFIG.RESOURCE_ROOT_PATH,
          CONFIG.SCRIPT_MARKET_ALIYUN_OSS_REPO_DIR,
          `${scriptMarket.configJSON.bucket}.${endpointObj.hostname}/${scriptMarket.configJSON.folder}`);
      return localAbsPath;

    case 'httpService':
      var urlObj = new URL(scriptMarket.configJSON.url);
      var localAbsPath = path.join(
          CONFIG.RESOURCE_ROOT_PATH,
          CONFIG.SCRIPT_MARKET_HTTP_SERVICE_REPO_DIR,
          `${urlObj.hostname}${urlObj.pathname}`);
      return localAbsPath;
  }
};

// 脚本市场 - 获取 META 数据
function _getMetaData(scriptMarket) {
  var localPath = _getLocalAbsPath(scriptMarket);
  var metaData  = {};

  var metaFilePath = path.join(localPath, CONFIG.SCRIPT_MARKET_META_FILE);
  if (!fs.existsSync(metaFilePath)) return metaData;

  var metaData = toolkit.safeReadFileSync(metaFilePath, 'yaml') || {};
  return metaData;
};

// 脚本市场 - 列出脚本集
function _listScriptSets(locals, scriptMarket, callback) {
  var scriptSets = [];
  async.series([
    function(asyncCallback) {
      SCRIPT_MARKET_RESET_FUNC_MAP[scriptMarket.type](locals, scriptMarket, function(err, metaData) {
        if (err) return asyncCallback(err);

        if (toolkit.notNothing(metaData)) {
          scriptSets = metaData.scriptSets || [];
        }

        return asyncCallback();
      });
    },
  ], function(err) {
    if (err) return callback(err);
    return callback(null, scriptSets);
  });
}

// 脚本市场 - 成为管理员
function _setAdmin(locals, scriptMarket, callback) {
  async.series([
    // 准备
    function(asyncCallback) {
      SCRIPT_MARKET_RESET_FUNC_MAP[scriptMarket.type](locals, scriptMarket, asyncCallback);
    },
    // 检查并修改 Token
    function(asyncCallback) {
      var token           = _getToken(scriptMarket);
      var remoteTokenInfo = _getRemoteTokenInfo(scriptMarket);

      if (!remoteTokenInfo.value) {
        // 尚未确定所有者，写入 Token
        return fs.outputFile(remoteTokenInfo.path, token, asyncCallback);

      } else if (remoteTokenInfo.value === token) {
        // 已经获得所有权，中断处理
        return callback();

      } else {
        // 已有其他 DataFlux Func 为管理员
        return asyncCallback(new E('EClient', 'Admin of the Script Market is already taken by other DataFlux Func'));
      }
    },
    // 上传
    function(asyncCallback) {
      var pushContent = {
        note: 'Set Token',
      }
      SCRIPT_MARKET_UPLOAD_REPO_FUNC_MAP[scriptMarket.type](locals, scriptMarket, pushContent, asyncCallback);
    },
  ], callback);
};

// 脚本市场 - 放弃管理员
function _unsetAdmin(locals, scriptMarket, callback) {
  async.series([
    // 准备
    function(asyncCallback) {
      SCRIPT_MARKET_RESET_FUNC_MAP[scriptMarket.type](locals, scriptMarket, asyncCallback);
    },
    // 检查并修改 Token
    function(asyncCallback) {
      var token           = _getToken(scriptMarket);
      var remoteTokenInfo = _getRemoteTokenInfo(scriptMarket);

      // 尚未获得所有权，中断处理
      if (!remoteTokenInfo.value || remoteTokenInfo.value !== token) return callback();

      // 已经获得所有权，删除 Token
      return fs.remove(remoteTokenInfo.path, asyncCallback);
    },
    // 上传
    function(asyncCallback) {
      var pushContent = {
        note: 'Unset Token',
      }
      SCRIPT_MARKET_UPLOAD_REPO_FUNC_MAP[scriptMarket.type](locals, scriptMarket, pushContent, asyncCallback);
    },
  ], callback);
};

// 脚本市场 - 推送
function _pushToScriptMarket(locals, scriptMarket, pushContent, callback) {
  var localPath = _getLocalAbsPath(scriptMarket);

  var metaData        = null;
  var tmpScriptSetMap = {};
  async.series([
    // 准备
    function(asyncCallback) {
      SCRIPT_MARKET_RESET_FUNC_MAP[scriptMarket.type](locals, scriptMarket, function(err, _metaData) {
        if (err) return asyncCallback(err);

        metaData = _metaData || {};

        // 添加推送信息
        metaData.note       = pushContent.note;
        metaData.exportUser = pushContent.exportUser;
        metaData.exportTime = pushContent.exportTime;

        // 临时脚本集索引
        if (toolkit.notNothing(metaData.scriptSets)) {
          tmpScriptSetMap = toolkit.arrayElementMap(metaData.scriptSets, 'id');
        }

        return asyncCallback();
      });
    },
    // 检查 Token
    function(asyncCallback) {
      var token           = _getToken(scriptMarket);
      var remoteTokenInfo = _getRemoteTokenInfo(scriptMarket);

      // 管理员为其他 DataFlux Func
      if (!remoteTokenInfo.value || remoteTokenInfo.value !== token) {
        return asyncCallback(new E('EClient', 'This DataFlux Func is not admin of the Script Market'));
      }

      return asyncCallback();
    },
    // 写入待推送文件
    function(asyncCallback) {
      try {
        // 删除脚本集（仅索引）
        if (toolkit.notNothing(pushContent.deleteScriptSetIds)) {
          pushContent.deleteScriptSets = [];

          pushContent.deleteScriptSetIds.forEach(function(scriptSetId) {
            var scriptSetToDelete = tmpScriptSetMap[scriptSetId];
            if (scriptSetToDelete) {
              // 删除索引
              delete tmpScriptSetMap[scriptSetId];

              // 记录被删除的脚本集信息
              pushContent.deleteScriptSets.push(scriptSetToDelete);
            }
          });
        }

        // 写入脚本集（索引 + 代码文件）
        if (toolkit.notNothing(pushContent.scriptSets)) {
          pushContent.scriptSets.forEach(function(scriptSet) {
            var scriptSetDir = path.join(localPath, CONFIG.SCRIPT_MARKET_SCRIPT_SET_DIR, scriptSet.id);

            // 生成脚本集 README
            var scriptSetReadmeFilePath = path.join(scriptSetDir, CONFIG.SCRIPT_EXPORT_README_FILE);
            var scriptSetReadmeData = _isAutoGeneratedFileOrNothing(scriptSetReadmeFilePath)
                                    ? _getDefaultScriptSetReadmeContent(scriptSet)
                                    : toolkit.safeReadFileSync(scriptSetReadmeFilePath);

            // 生成脚本集 CHANGELOG 信息
            var scriptSetChangelogInfoFilePath = path.join(scriptSetDir, CONFIG.SCRIPT_MARKET_CHANGELOG_INFO_FILE);
            var changelogInfoData = toolkit.safeReadFileSync(scriptSetChangelogInfoFilePath, 'yaml');
            changelogInfoData = _addChangelogInfo(changelogInfoData, scriptSet);

            var scriptSetChangelogFilePath = path.join(scriptSetDir, CONFIG.SCRIPT_MARKET_CHANGELOG_FILE);
            var scriptSetChangelogData = _isAutoGeneratedFileOrNothing(scriptSetChangelogFilePath)
                                    ? _getDefaultScriptSetChangelogContent(changelogInfoData)
                                    : toolkit.safeReadFileSync(scriptSetChangelogFilePath);

            // 准备脚本集文件夹
            fs.emptyDirSync(scriptSetDir);

            // 写入 README
            fs.outputFileSync(scriptSetReadmeFilePath, scriptSetReadmeData);

            // 写入 CHANGELOG
            fs.outputFileSync(scriptSetChangelogInfoFilePath, _addAutoGeneratedInfo(yaml.dump(changelogInfoData), 'yaml'));
            fs.outputFileSync(scriptSetChangelogFilePath, scriptSetChangelogData);

            // 写入脚本文件
            if (toolkit.notNothing(scriptSet.scripts)) {
              scriptSet.scripts.forEach(function(script) {
                var filePath = path.join(scriptSetDir, common.getScriptFilename(script));
                fs.outputFileSync(filePath, script.code || '');

                // 去除 META 中代码
                delete script.code;
              });
            }

            // 添加到索引
            tmpScriptSetMap[scriptSet.id] = scriptSet;
          });
        }

        // 重建并写入 META
        metaData.scriptSets = Object.values(tmpScriptSetMap);
        fs.outputFileSync(path.join(localPath, CONFIG.SCRIPT_MARKET_META_FILE), yaml.dump(metaData));

        // 写入脚本市场 README 文件
        var scriptMarketReadmeFilePath = path.join(localPath, CONFIG.SCRIPT_EXPORT_README_FILE);
        if (_isAutoGeneratedFileOrNothing(scriptMarketReadmeFilePath)) {
          var scriptMarketReadmeData = _getDefaultScriptMarketReadmeContent(scriptMarket, pushContent);
          fs.outputFileSync(scriptMarketReadmeFilePath, scriptMarketReadmeData);
        }

        return asyncCallback();

      } catch(err) {
        return asyncCallback(err);
      }
    },
    // 上传
    function(asyncCallback) {
      SCRIPT_MARKET_UPLOAD_REPO_FUNC_MAP[scriptMarket.type](locals, scriptMarket, pushContent, asyncCallback);
    },
  ], callback);
};

// 脚本市场 - 拉取
function _pullFromScriptMarket(locals, scriptMarket, pullScriptSetIds, callback) {
  if (toolkit.isNothing(pullScriptSetIds)) {
    return callback(new E('EClient', 'Nothing to pull'));
  }

  var localPath = _getLocalAbsPath(scriptMarket);

  var pullContent = {
    scriptSets: [],
  };

  var metaData        = null;
  var tmpScriptSetMap = null;
  async.series([
    // 准备
    function(asyncCallback) {
      SCRIPT_MARKET_RESET_FUNC_MAP[scriptMarket.type](locals, scriptMarket, function(err, _metaData) {
        if (err) return asyncCallback(err);

        metaData        = _metaData || {};
        tmpScriptSetMap = toolkit.arrayElementMap(metaData.scriptSets || [], 'id');

        return asyncCallback();
      });
    },
    // 下载必要内容
    function(asyncCallback) {
      var files = [];

      pullScriptSetIds.forEach(function(scriptSetId) {
        var scriptSet = tmpScriptSetMap[scriptSetId];

        if (toolkit.isNothing(scriptSet))         return;
        if (toolkit.isNothing(scriptSet.scripts)) return;

        scriptSet.scripts.forEach(function(script) {
          var codeFilePath = path.join(CONFIG.SCRIPT_MARKET_SCRIPT_SET_DIR, scriptSetId, common.getScriptFilename(script));
          files.push(codeFilePath);
        })
      });

      async.eachLimit(files, 5, function(file, eachCallback) {
        SCRIPT_MARKET_DOWNLOAD_FUNC_MAP[scriptMarket.type](scriptMarket, localPath, file, asyncCallback);
      }, asyncCallback);
    },
    // 生成导入信息
    function(asyncCallback) {
      pullScriptSetIds.forEach(function(scriptSetId) {
        // 读取代码
        var scriptSet = tmpScriptSetMap[scriptSetId];
        scriptSet.scripts.forEach(function(script) {
          var codeFilePath = path.join(localPath, CONFIG.SCRIPT_MARKET_SCRIPT_SET_DIR, scriptSetId, common.getScriptFilename(script));
          script.code = toolkit.safeReadFileSync(codeFilePath);
        });

        pullContent.scriptSets.push(scriptSet);
      });

      return asyncCallback();
    },
  ], function(err) {
    if (err) return callback(err);
    return callback(null, pullContent);
  });
};

/* Handlers */
var crudHandler = exports.crudHandler = scriptMarketMod.createCRUDHandler();

exports.list = function(req, res, next) {
  var scriptMarkets        = null;
  var scriptMarketPageInfo = null;

  var scriptMarketModel = scriptMarketMod.createModel(res.locals);
  var scriptMarketModelForFetch = scriptMarketMod.createModel(res.locals);
  scriptMarketModelForFetch.decipher = true;

  async.series([
    // 获取脚本市场列表
    function(asyncCallback) {
      var opt = res.locals.getQueryOptions();

      scriptMarketModel.list(opt, function(err, dbRes, pageInfo) {
        if (err) return asyncCallback(err);

        scriptMarkets        = dbRes;
        scriptMarketPageInfo = pageInfo;

        return asyncCallback();
      });
    },
  ], function(err) {
    if (err) return next(err);

    // 获取脚本市场管理员信息、脚本集 META 信息等
    scriptMarkets.forEach(function(scriptMarket) {
      // 获取 META 信息
      scriptMarket.scriptSets = _getMetaData(scriptMarket).scriptSets || [];

      // 检查是否为管理员
      var token       = _getToken(scriptMarket);
      var remoteToken = _getRemoteTokenInfo(scriptMarket).value;
      scriptMarket.isAdmin = (token === remoteToken);
    });

    var ret = toolkit.initRet(scriptMarkets, scriptMarketPageInfo);
    res.locals.sendJSON(ret);
  });
};

exports.add = function(req, res, next) {
  var data = _prepareConfig(req.body.data);

  var scriptMarketModel = scriptMarketMod.createModel(res.locals);

  // 预分配 ID，保证正常生成 TOKEN
  data.id = scriptMarketModel.genDataId();

  var newScriptMarket = null;

  async.series([
    // 检查脚本市场配置
    function(asyncCallback) {
      if (toolkit.isNothing(data.configJSON)) return asyncCallback();

      return _checkConfig(res.locals, data, asyncCallback);
    },
    // 加载脚本市场
    function(asyncCallback) {
      SCRIPT_MARKET_INIT_FUNC_MAP[data.type](res.locals, data, asyncCallback);
    },
    // 尝试获取所有权
    function(asyncCallback) {
      // 非读写库，跳过
      if (SCRIPT_MARKET_RW_MAP[data.type] !== 'rw') return asyncCallback();

      // 未填写平台账号，跳过
      switch(data.type) {
        case 'git':
          if (!data.configJSON
              || !data.configJSON.user
              || !data.configJSON.password) {
            return asyncCallback();
          }
          break;
      }

      _setAdmin(res.locals, data, function(err) {
        // 出错表示无法获取所有权，跳过
        if (err) res.locals.logger.error(err.toString());

        return asyncCallback();
      });
    },
    // 数据入库
    function(asyncCallback) {
      scriptMarketModel.add(data, function(err, _addedId, _addedData) {
        if (err) return asyncCallback(err);

        newScriptMarket = _addedData;

        return asyncCallback();
      });
    },
  ], function(err) {
    if (err) return next(err);

    var ret = toolkit.initRet({
      id: newScriptMarket.id,
    });
    return res.locals.sendJSON(ret);
  });
};

exports.addOfficial = function(req, res, next) {
  var data = CONFIG._OFFICIAL_SCRIPT_MARKET;

  var scriptMarketModel = scriptMarketMod.createModel(res.locals);

  async.series([
    // 加载脚本市场
    function(asyncCallback) {
      SCRIPT_MARKET_INIT_FUNC_MAP[data.type](res.locals, data, asyncCallback);
    },
    // 数据入库
    function(asyncCallback) {
      scriptMarketModel.add(data, asyncCallback);
    },
  ], function(err) {
    if (err) return next(err);

    var ret = toolkit.initRet({
      id: data.id,
    });
    return res.locals.sendJSON(ret);
  });
};

exports.modify = function(req, res, next) {
  var id   = req.params.id;
  var data = _prepareConfig(req.body.data);

  var scriptMarketModel = scriptMarketMod.createModel(res.locals);

  var scriptMarket = null;

  async.series([
    // 获取脚本市场
    function(asyncCallback) {
      scriptMarketModel.getWithCheck(id, null, function(err, dbRes) {
        if (err) return asyncCallback(err);

        scriptMarket = dbRes;

        return asyncCallback();
      });
    },
    // 检查脚本市场配置
    function(asyncCallback) {
      if (toolkit.isNothing(data.configJSON)) return asyncCallback();

      return _checkConfig(res.locals, data, asyncCallback);
    },
    // 加载脚本市场
    function(asyncCallback) {
      if (toolkit.isNothing(data.configJSON)) return asyncCallback();

      Object.assign(scriptMarket, data);
      SCRIPT_MARKET_INIT_FUNC_MAP[scriptMarket.type](res.locals, scriptMarket, asyncCallback);
    },
    // 数据入库
    function(asyncCallback) {
      scriptMarketModel.modify(id, data, asyncCallback);
    },
  ], function(err) {
    if (err) return next(err);

    var ret = toolkit.initRet({
      id: id,
    });
    return res.locals.sendJSON(ret);
  });
};

exports.delete = function(req, res, next) {
  var id = req.params.id;

  var scriptMarketModel = scriptMarketMod.createModel(res.locals);
  scriptMarketModel.decipher = true;

  var scriptMarket = null;

  async.series([
    // 获取脚本市场
    function(asyncCallback) {
      scriptMarketModel.getWithCheck(id, null, function(err, dbRes) {
        if (err) return asyncCallback(err);

        scriptMarket = dbRes;

        // 非读写库，跳过
        if (SCRIPT_MARKET_RW_MAP[scriptMarket.type] !== 'rw') return asyncCallback();

        // 未填写平台账号，跳过
        switch(scriptMarket.type) {
          case 'git':
            if (!scriptMarket.configJSON
                || !scriptMarket.configJSON.user
                || !scriptMarket.configJSON.password) {
              return asyncCallback();
            }
            break;
        }

        // 放弃所有权（忽略错误）
        _unsetAdmin(res.locals, scriptMarket, function(err) {
          // 出错表示无法放弃所有权，忽略
          if (err) res.locals.logger.error(err.toString());
        });

        return asyncCallback();
      });
    },
    // 数据入库
    function(asyncCallback) {
      scriptMarketModel.delete(id, asyncCallback);
    },
  ], function(err) {
    if (err) return next(err);

    var ret = toolkit.initRet({
      id: id,
    });
    return res.locals.sendJSON(ret);
  });
};

exports.listScriptSets = function(req, res, next) {
  var id = req.params.id;

  var scriptMarketModel = scriptMarketMod.createModel(res.locals);
  scriptMarketModel.decipher = true;

  var scriptSets   = [];
  var scriptMarket = null;
  async.series([
    // 获取脚本市场
    function(asyncCallback) {
      scriptMarketModel.getWithCheck(id, null, function(err, dbRes) {
        if (err) return asyncCallback(err);

        scriptMarket = dbRes;

        return asyncCallback();
      })
    },
    // 列出脚本市场脚本集
    function(asyncCallback) {
      _listScriptSets(res.locals, scriptMarket, function(err, _scriptSets) {
        if (err) {
          return asyncCallback(new E('EBizCondition.FetchScriptMarketFailed', 'Fetch Script Market Script Set list Failed', {
            message: err.toString(),
          }));
        }

        scriptSets = _scriptSets;

        return asyncCallback();
      });
    },
  ], function(err) {
    if (err) return next(err);

    var ret = toolkit.initRet(scriptSets);
    return res.locals.sendJSON(ret);
  });
};

exports.setAdmin = function(req, res, next) {
  var id = req.params.id;

  var scriptMarketModel = scriptMarketMod.createModel(res.locals);
  scriptMarketModel.decipher = true;

  var scriptMarket = null;
  async.series([
    // 获取脚本市场
    function(asyncCallback) {
      scriptMarketModel.getWithCheck(id, null, function(err, dbRes) {
        if (err) return asyncCallback(err);

        scriptMarket = dbRes;

        if (SCRIPT_MARKET_RW_MAP[scriptMarket.type] !== 'rw') {
          return asyncCallback(new E('EBizCondition', 'This operation is not supported on this type of Script Market'));
        }

        return asyncCallback();
      })
    },
    // 获取所有权
    function(asyncCallback) {
      return _setAdmin(res.locals, scriptMarket, asyncCallback);
    },
  ], function(err) {
    if (err) return next(err);

    var ret = toolkit.initRet();
    return res.locals.sendJSON(ret);
  });
};

exports.unsetAdmin = function(req, res, next) {
  var id = req.params.id;

  var scriptMarketModel = scriptMarketMod.createModel(res.locals);
  scriptMarketModel.decipher = true;

  var scriptMarket = null;
  async.series([
    // 获取脚本市场
    function(asyncCallback) {
      scriptMarketModel.getWithCheck(id, null, function(err, dbRes) {
        if (err) return asyncCallback(err);

        scriptMarket = dbRes;

        if (SCRIPT_MARKET_RW_MAP[scriptMarket.type] !== 'rw') {
          return asyncCallback(new E('EBizCondition', 'This operation is not supported on this type of Script Market'));
        }

        return asyncCallback();
      })
    },
    // 放弃所有权
    function(asyncCallback) {
      return _unsetAdmin(res.locals, scriptMarket, asyncCallback);
    },
  ], function(err) {
    if (err) return next(err);

    var ret = toolkit.initRet();
    return res.locals.sendJSON(ret);
  });
};

exports.publish = function(req, res, next) {
  var id           = req.params.id;
  var scriptSetIds = req.body.scriptSetIds;
  var mode         = req.body.mode;
  var note         = req.body.note;

  var scriptSetModel    = scriptSetMod.createModel(res.locals);
  var scriptMarketModel = scriptMarketMod.createModel(res.locals);
  scriptMarketModel.decipher = true;

  var scriptMarket = null;
  var pushContent  = null;

  async.series([
    // 获取脚本市场
    function(asyncCallback) {
      scriptMarketModel.getWithCheck(id, null, function(err, dbRes) {
        if (err) return asyncCallback(err);

        scriptMarket = dbRes;

        if (SCRIPT_MARKET_RW_MAP[scriptMarket.type] !== 'rw') {
          return asyncCallback(new E('EBizCondition', 'This operation is not supported on this type of Script Market'));
        }

        return asyncCallback();
      })
    },
    // 获取导出数据
    function(asyncCallback) {
      if (mode === 'add') {
        // 添加模式
        var opt = {
          scriptSetIds: scriptSetIds,
          note        : note,
        }
        scriptSetModel.getExportData(opt, function(err, exportData, summary) {
          if (err) return asyncCallback(err);

          pushContent = exportData;

          return asyncCallback();
        });

      } else {
        // 删除模式
        pushContent = {
          deleteScriptSetIds: scriptSetIds,
          exportUser        : common.getExportUser(res.locals),
          exportTime        : toolkit.getISO8601(),
          note              : note,
        }
        return asyncCallback();
      }
    },
    // 推送数据
    function(asyncCallback) {
      _pushToScriptMarket(res.locals, scriptMarket, pushContent, asyncCallback);
    },
  ], function(err) {
    if (err) return next(err);

    var ret = toolkit.initRet();
    return res.locals.sendJSON(ret);
  });
};

exports.install = function(req, res, next) {
  var id           = req.params.id;
  var scriptSetIds = req.body.scriptSetIds;

  var scriptSetModel    = scriptSetMod.createModel(res.locals);
  var scriptMarketModel = scriptMarketMod.createModel(res.locals);
  scriptMarketModel.decipher = true;

  var scriptMarket = null;
  var importData  = null;
  var requirements = null;

  async.series([
    // 获取脚本市场
    function(asyncCallback) {
      scriptMarketModel.getWithCheck(id, null, function(err, dbRes) {
        if (err) return asyncCallback(err);

        scriptMarket = dbRes;

        return asyncCallback();
      })
    },
    // 获取拉取数据数据
    function(asyncCallback) {
      _pullFromScriptMarket(res.locals, scriptMarket, scriptSetIds, function(err, _importData) {
        if (err) return asyncCallback(err);

        importData = _importData;

        // 替换 origin, originId
        common.replaceImportDataOrigin(importData, 'scriptMarket', scriptMarket.id);

        return asyncCallback();
      });
    },
    // 导入数据
    function(asyncCallback) {
      var recoverPoint = {
        type: 'install',
        note: '系统：安装脚本集前自动创建的还原点',
      };
      scriptSetModel.import(importData, recoverPoint, function(err, _requirements) {
        if (err) return asyncCallback(err);

        requirements = _requirements;

        return asyncCallback();
      });
    },
  ], function(err) {
    if (err) return next(err);

    var ret = toolkit.initRet({
      requirements: requirements,
    });
    return res.locals.sendJSON(ret);
  });
};

exports.checkUpdate = function(req, res, next) {
  var scriptModel       = scriptMod.createModel(res.locals);
  var scriptSetModel    = scriptSetMod.createModel(res.locals);
  var scriptMarketModel = scriptMarketMod.createModel(res.locals);
  scriptMarketModel.decipher = true;

  var localScriptSetMap  = null;
  var remoteScriptSetMap = {};

  var scriptMarketIds = null;
  var scriptMarkets   = null;

  var updatedScriptSets = [];

  async.series([
    // 获取本地脚本集（仅涉及脚本市场的）
    function(asyncCallback) {
      var fields = common.getScriptSetMD5Fields('sset');
      fields.push('sset.originId');

      var opt = {
        fields: fields,
        filters: {
          origin: { eq: 'scriptMarket' },
        }
      }
      scriptSetModel.list(opt, function(err, dbRes) {
        if (err) return asyncCallback(err);

        scriptMarketIds = toolkit.arrayElementValues(dbRes, 'originId', true);
        localScriptSetMap = dbRes.reduce(function(acc, x) {
          var keyObj = { scriptMarketId: x.originId, scriptSetId: x.id };
          var key    = sortedJSON.sortify(keyObj, { stringify: true });
          acc[key] = x;
          return acc;
        }, {});

        return asyncCallback();
      })
    },
    // 获取脚本市场
    function(asyncCallback) {
      scriptMarketModel.list(null, function(err, dbRes) {
        if (err) return asyncCallback(err);

        scriptMarkets = dbRes;

        return asyncCallback();
      });
    },
    // 获取远端脚本集
    function(asyncCallback) {
      if (toolkit.isNothing(scriptMarkets)) return asyncCallback();

      async.eachLimit(scriptMarkets, 5, function(scriptMarket, eachCallback) {
        _listScriptSets(res.locals, scriptMarket, function(err, _scriptSets) {
          // 检查更新不报错
          if (err) return asyncCallback();

          if (toolkit.notNothing(_scriptSets)) {
            _scriptSets.forEach(function(_scriptSet) {
              var keyObj = { scriptMarketId: scriptMarket.id, scriptSetId: _scriptSet.id };
              var key    = sortedJSON.sortify(keyObj, { stringify: true });
              remoteScriptSetMap[key] = _scriptSet;
            });
          }
          return eachCallback();
        });
      }, asyncCallback);
    },
    // 对比本地-远端脚本 MD5
    function(asyncCallback) {
      if (toolkit.isNothing(remoteScriptSetMap)) return asyncCallback();

      async.eachOfSeries(remoteScriptSetMap, function(remoteScriptSet, key, eachCallback) {
        var localScriptSet = localScriptSetMap[key];

        if (!localScriptSet) return eachCallback();

        var keyObj = JSON.parse(key);
        var opt = {
          fields: common.getScriptMD5Fields('scpt'),
          filters: {
            scriptSetId: { eq: keyObj.scriptSetId }
          }
        }
        scriptModel.list(opt, function(err, dbRes) {
          if (err) return eachCallback(err);

          var localMD5 = common.getScriptSetMD5(localScriptSet, dbRes);
          var remoteMD5 = remoteScriptSet._md5;
          if (localMD5 !== remoteMD5) {
            // 脚本集 MD5 不一致，记录更新信息
            updatedScriptSets.push(keyObj);
          }

          return eachCallback();
        });
      }, asyncCallback);
    },
  ], function(err) {
    if (err) return next(err);

    var ret = toolkit.initRet({
      updatedScriptSets: updatedScriptSets,
    });
    return res.locals.sendJSON(ret);
  });
};